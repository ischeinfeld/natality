---
title: 'US Natality Data: Causal Inference Case Study'
output:
  html_document:
    df_print: paged
---

```{r echo=TRUE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE, comment=NA)

library(ggplot2)   # plot
library(dplyr)     # tables
library(readr)     # reading
library(stringr)   # strings
library(purrr)     # fp
library(tidyr)     # remove_na
library(forcats)   # factor recode
library(glmnet)    # lasso
library(grf)       # random forests
library(janitor)   # remove_constant columns
library(corrplot)  # plot correlation matrix
#library(sufrep)   # sufficient representations
source("make_encoder.R") # modified sufficient representations

rm(list = ls())    # reset environment
source("utils.R")  # import helpers

# The seed is set before every randomized operation throughout so results
# are consistent when rerunning cells.
```

# Subset and preprocess data

```{r}
# In theory variable, currently only 2002 preprocessing implemented
year <- 2002 

# Select outcome and binary/continuous treatments
# Code supports either tobacco/cigar or alcohol/drink treatments
Yname <- "dbirwt"      # outcome
Wname_bin <- "tobacco" # binary treatment
Wname_cnt <- "cigar"   # continuous treatment

# Beginning data size 100,000
data_size <- as.integer(1e5)
```

To begin with we sample 100,000 birth records uniformly at random and preprocess
their columns types from the raw CSV to encode each variable as an integer or 
an ordered or unordered factor. All values coded as missing or undetermined
are considered NA.

```{r}
subset <- FALSE

subset_fname <- paste0("../data/subset_rds/natl", year, ".rds")

if (subset) {
  raw_fname <- paste0("../data/raw_csv/natl", year, ".csv")
  set.seed(50)
  # select a random sample
  natl_raw <- 
    read_csv(raw_fname, col_types = cols(.default = col_character())) %>%
    sample_n(data_size)

  write_rds(natl_raw, subset_fname, compress = "gz")
}
```

Convert text csv to factors using preprocessing code from `preprocess_natl2002.R`.
This mostly just fixes the factor levels to match those described in the data 
[documentation](https://data.nber.org/natality/2002/natl2002.pdf). It does make
some changes to the coding as noted at the top of the preprocessing code. 

```{r}
preprocess <- FALSE

preprocessed_fname <- paste0("../data/preprocessed_rds/natl", year, ".rds")

if (preprocess) {
  source(paste0("preprocess/preprocess_natl", year, ".R"))
  # preprocess natl, fix types / levels and modify variables (monpre, dmar)
  natl <- read_rds(subset_fname) %>%
    preprocess_natl()
  
  write_rds(natl, preprocessed_fname, compress = "gz")
}

natl_full <- read_rds(preprocessed_fname)
```

# Prepare Data

The following variables will be considered in our analysis. Since the original
natality dataset contains multiple codings for the same variables, here we
select a single coding per variable of interest. Some other variables have been
dropped as well, and ?/? of original data covariates are listed. 

```{r}
# variables (with most specific coding) available for analysis
natl_names <- list(
  general = c("restatus",   # Resident Status
              "pldel",      # Place or Facility of Birth
              "birattnd"),  # Attendant at Birth
  occur =   c("stnatexp",   # Expanded State of Occurrence
              "cntocpop"),  # Population Size of County of Occurrence
  resid =   c("stresexp",   # Expanded State of Residence
              "cntrspop",   # Population Size of County of Residence
              "citrspop",   # Population Size of City of Residence
              "metrores",   # Metropolitan - Non-metropolitan County of Residence
              "cntrspop"),  # Population Size of County of Residence
  mother =  c("dmage",      # Age of Mother
              "ormoth",     # Hispanic Origin of Mother
              "mrace",      # Race of Mother
              "dmeduc",     # Education of Mother
              "dmar",       # Marital status MODIFIED
              "mplbir",     # Place of Birth of Mother
              "adequacy",   # Adequacy Of Care Recode (Kessner Index)
              "nlbnl",      # Number of Live Births Now Living
              "nlbnd",      # Number of Live Births Now Dead
              "noterm",     # Number of Other Terminations
              "dlivord",    # Detail Live Birth Order (nlbnl + nlbnd + 1)
              "monpre",     # Detail Month of Pregnancy Prenatal Care Began MODIFIED
              "nprevis"),   # Total Number of Prenatal Visits
  father =  c("dfage",      # Age of Father
              "orfath",     # Hispanic Origin of Father
              "frace"),     # Race of Father
  child =   c("dgestat",    # Gestation - Detail in Weeks
              "csex",       # Sex
              "dbirwt",     # Birth Weight - Detail in Grams
              "dplural",    # Plurality
              "fmaps",      # Five Minute Apgar Score
              "delmeth5"),  # Method of Delivery Recode
  med_rsk = c("anemia", "cardiac", "lung", "diabetes", "herpes", "hydra", "hemo",
              "chyper", "phyper", "eclamp", "incervix", "pre4000", "preterm",
              "renal", "rh", "uterine", "othermr"),
  # currently code supports W either tobacco/cigar or alcohol/drink
  oth_rsk = c("tobacco",    # Tobacco Use During Pregnancy
              "cigar",      # Average Number of Cigarettes Per Day
              "alcohol",    # Alcohol Use During Pregnancy
              "drink",      # Average Number of Drinks Per Week
              "wtgain"),    # Weight Gain
  obstetr = c("amnio", "monitor", "induct", "stimula", "tocol", "ultras", "otherob"),
  lab_cmp = c("febrile", "meconium", "rupture", "abruptio", "preplace", "excebld",
              "seizure", "precip", "prolong", "dysfunc", "breech", "cephalo",
              "cord", "anesthe", "distress", "otherlb"),
  newborn = c("nanemia", "injury", "alcosyn", "hyaline", "meconsyn", "venl30",
              "ven30m", "nseiz", "otherab"),
  congntl = c("anen", "spina", "hydro", "microce", "nervous", "heart", "circul",
              "rectal", "tracheo", "omphalo", "gastro", "genital", "renalage", 
              "urogen", "cleftlp", "adactyly", "clubfoot", "hernia", "musculo"))

# Select covariates
Xnames <- with(natl_names, c(general, occur, resid, mother, father))
Xnames <- c(Xnames, # add risk factors besides those considered treatments
            setdiff(natl_names$oth_rsk, c(Wname_bin, Wname_cnt)))
Xnames <- setdiff(Xnames, c("pldel", "birattnd")) # remove filter variables

# filter data
natl <- natl_full %>%
  filter(pldel == 1 && birattnd == 1) %>% # hospital birth with doctor attending
  select(all_of(c(Yname, Wname_bin, Wname_cnt, Xnames))) %>% # select columns
  drop_na(all_of(c(Yname, Wname_bin, Wname_cnt))) # Y, W are not NA

# save model data
natl_fname <- paste0("../models/natl/natl", year, Wname_bin, "-", Wname_cnt, ".rds")
write_rds(natl, natl_fname, compress = "gz")
```

As a sanity check for our preprocessing and to start exploring the data, we
tabulate some quick summary information.

```{r}
natl %>%
  summarise(across(.fns = function (x) sum(is.na(x)) / length(x))) %>%
  pivot_longer(cols = everything()) %>%
  arrange(desc(value)) %>%
  rename(fracNA = value) %>%
  head(8)
```

The top 5 missing variables are mother's place of birth, population size of 
county of occurrence, and fathers race, origin, and age. All other variables
are missing less than in less than 5% of samples. 

Note that missing values in this dataset can be due to a variety of factors. A
large proportion of missingness is explained by regional variations in reporting,
leading to some very high correlations between variables, while some weaker 
correlations may be due to other various causes.

```{r}
set.seed(186)
M <- natl %>%
  sample_n(1000) %>%
  summarise(across(.fns = is.na)) %>%
  remove_constant() %>%
  cor()

# plot NA fraction correlations
corrplot(M, method="circle", order="hclust", tl.col = "black")
```

# Factor Representation / Group Encoding

Our models will require exclusively numeric-valued inputs, and we therefore need
to encode group-valued variables as numeric. First we split the data into 
variables that can be directly converted to numbers (i.e.numeric values, ordered
factors, and binary factors) from those that require group encoding.

```{r}
# numeric values
natl_num <- natl %>% 
  select_if(is.numeric)

# ordered factors
natl_ord <- natl %>% 
  select_if(function (col) (is.factor(col) && is.ordered(col))) %>%
  # preserve numeric coding of factor levels instead of level index
  transmute(across(everything(), ~ as.numeric(as.character(.))))

# binary factors
natl_bin <- natl %>% 
  select_if(function (col) (is.factor(col) && nlevels(col) == 2)) %>%
  transmute(across(everything(), function(col) col == "yes"))

# combine ordered types
natl_num <- bind_cols(natl_num, natl_ord, natl_bin)

# unordered factors that need encoding
natl_grp <- natl %>%
  select(-one_of(names(natl_num)))

ncol(natl_num)
ncol(natl_grp)
```

Note that simply using one-hot encoding would massively expands the number of 
variables since some of our group variables have many levels (i.e. 50+ states). 

```{r}
natl_grp_nlevels <- sapply(natl_grp, nlevels)
natl_grp_nlevels
```

Most of the one-hot dimensions come from `stnatexp`, `stresexp`, and `mplbir`,
all of which are geographic variables. The race variables `mrace` and `frace`
also contribute many group levels / dimensions. For these variables specifically,
it would be helpful to use alternate encodings.

One alternate class of encoding schemes, sufficient representations, are 
described in (TODO cite). We define different encoding types for the group
variables based on their level counts.

```{r}
natl_grp_encoding_types <- natl_grp_nlevels %>%
  map(function(nlevels) {
    # use sparse low rank where one-hot would be "too" high dimensional
    if (nlevels < 10) "one_hot" else "sparse_low_rank"
  })
```

We then generate encoders of these types. Note that our modification of the
`sufrep` code currently makes an encoding of the NAs in the factor as a separate 
level. An alternate approach would be to leave NA values NA in all their 
dimensions.

```{r}
# Make sure we have our modified make_encoder that works with NA values. 
source("make_encoder.R")

natl_grp_encoders <- map2(natl_grp_encoding_types, natl_grp,
  function(encoding, G) {
    make_encoder(encoding,
                 X = as.matrix(select(natl_num,
                               -all_of(c(Yname, Wname_bin, Wname_cnt)))), 
                 G = G, num_components = 5)
  })
```

Generate the corresponding encodings on our data.

```{r}
natl_grp_encodings <- natl_grp_encoders %>%
  map2(natl_grp, # apply encoder function .x
       ~ as.data.frame(.x(X = as.matrix(natl_num), G = .y))) %>%
  map2_dfc(names(natl_grp), # rename columns "varname.dim"
       ~ rename_with(.x, function (x) paste(.y, 1:length(.x), sep=".")))
```

Finally, recombine with the numeric variables to give our data matrix.

```{r}
# combine numeric and encoded group variables
natl_rep <- bind_cols(natl_num, natl_grp_encodings)

# save model data
natl_rep_fname <- paste0("../models/natl_rep/natl", year, Wname_bin, "-", Wname_cnt, ".rds")
write_rds(natl_rep, natl_rep_fname, compress = "gz")

head(natl_rep)
```

# Training

```{r}
Xmod <- as.matrix(natl_rep %>% select(-all_of(c(Yname, Wname_bin, Wname_cnt))))
Ymod <- natl_rep[[Yname]]
Wmod_bin <- natl_rep[[Wname_bin]]
Wmod_cnt <- natl_rep[[Wname_cnt]]
```

Train causal forests for binary and continuous treatments.

```{r}
train <- FALSE
train_fname <- paste0("../models/causal_forests/natl", year, Wname_bin, ".rds")

if (train) {
  tau_bin.forest <- causal_forest(Xmod, Ymod, Wmod_bin, seed=318)
  write_rds(tau_bin.forest, train_fname)
} else {
  tau_bin.forest <- read_rds(train_fname)
}
```

```{r}
train <- FALSE
train_fname <- paste0("../models/causal_forests/natl", year, Wname_cnt, ".rds")

if (train) {
  tau_cnt.forest <- causal_forest(Xmod, Ymod, Wmod_cnt, seed=330)
  write_rds(tau_cnt.forest, train_fname)
} else {
  tau_cnt.forest <- read_rds(train_fname)
}
```

We can now use these forests in further analysis.

```{r}
average_treatment_effect(tau_bin.forest)
```

```{r}
average_treatment_effect(tau_bin.forest, target.sample = "treated")
```

```{r}
average_partial_effect(tau_cnt.forest)
```